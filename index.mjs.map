{"version":3,"file":"index.mjs","sources":["../lib/create_table.js","../lib/rand_int32.js","../lib/factory.js","../lib/index.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isnan = require( '@stdlib/math-base-assert-is-nan' );\n\n\n// VARIABLES //\n\nvar NUM_WARMUPS = 8;\n\n\n// MAIN //\n\n/**\n* Initializes a shuffle table.\n*\n* @private\n* @param {PRNG} rand - pseudorandom number generator\n* @param {Int32Array} table - table\n* @param {PositiveInteger} N - table size\n* @throws {Error} PRNG returned `NaN`\n* @returns {NumberArray} shuffle table\n*/\nfunction createTable( rand, table, N ) {\n\tvar v;\n\tvar i;\n\n\t// \"warm-up\" the PRNG...\n\tfor ( i = 0; i < NUM_WARMUPS; i++ ) {\n\t\tv = rand();\n\n\t\t// Prevent the above loop from being discarded by the compiler...\n\t\tif ( isnan( v ) ) {\n\t\t\tthrow new Error( 'unexpected error. PRNG returned `NaN`.' );\n\t\t}\n\t}\n\t// Initialize the shuffle table...\n\tfor ( i = N-1; i >= 0; i-- ) {\n\t\ttable[ i ] = rand();\n\t}\n\treturn table;\n}\n\n\n// EXPORTS //\n\nmodule.exports = createTable;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar INT32_MAX = require( '@stdlib/constants-int32-max' );\nvar floor = require( '@stdlib/math-base-special-floor' );\n\n\n// VARIABLES //\n\nvar MAX = INT32_MAX - 1;\n\n\n// MAIN //\n\n/**\n* Returns a pseudorandom integer on the interval \\\\([1, 2^{31}-1)\\\\).\n*\n* @private\n* @returns {PositiveInteger} pseudorandom integer\n*\n* @example\n* var v = randint32();\n* // returns <number>\n*/\nfunction randint32() {\n\tvar v = floor( 1.0 + (MAX*Math.random()) ); // eslint-disable-line stdlib/no-builtin-math\n\treturn v|0; // asm type annotation\n}\n\n\n// EXPORTS //\n\nmodule.exports = randint32;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar setReadOnlyAccessor = require( '@stdlib/utils-define-nonenumerable-read-only-accessor' );\nvar setReadWriteAccessor = require( '@stdlib/utils-define-nonenumerable-read-write-accessor' );\nvar hasOwnProp = require( '@stdlib/assert-has-own-property' );\nvar isObject = require( '@stdlib/assert-is-plain-object' );\nvar isBoolean = require( '@stdlib/assert-is-boolean' ).isPrimitive;\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar isPositiveInteger = require( '@stdlib/assert-is-positive-integer' ).isPrimitive;\nvar isInt32Array = require( '@stdlib/assert-is-int32array' );\nvar gcopy = require( '@stdlib/blas-base-gcopy' );\nvar floor = require( '@stdlib/math-base-special-floor' );\nvar Int32Array = require( '@stdlib/array-int32' );\nvar INT32_MAX = require( '@stdlib/constants-int32-max' );\nvar typedarray2json = require( '@stdlib/array-to-json' );\nvar format = require( '@stdlib/string-format' );\nvar createTable = require( './create_table.js' );\nvar randint32 = require( './rand_int32.js' );\n\n\n// VARIABLES //\n\nvar NORMALIZATION_CONSTANT = (INT32_MAX - 1)|0; // asm type annotation\nvar MAX_SEED = (INT32_MAX - 1)|0; // asm type annotation\nvar A = 16807|0; // asm type annotation\n\n// Define the number of elements in the shuffle table:\nvar TABLE_LENGTH = 32;\n\n// Define the state array schema version:\nvar STATE_ARRAY_VERSION = 1; // NOTE: anytime the state array schema changes, this value should be incremented!!!\n\n// Define the number of sections in the state array:\nvar NUM_STATE_SECTIONS = 3; // table, other, seed\n\n// Define the index offset of the \"table\" section in the state array:\nvar TABLE_SECTION_OFFSET = 2; // | version | num_sections | table_length | ...table | other_length | shuffle_state | prng_state | seed_length | ...seed |\n\n// Define the index offset of the \"state\" section in the state array:\nvar STATE_SECTION_OFFSET = TABLE_LENGTH + 3; // | version | num_sections | table_length | ...table | state_length | shuffle_state | prng_state | seed_length | ...seed |\n\n// Define the index offset of the seed section in the state array:\nvar SEED_SECTION_OFFSET = TABLE_LENGTH + 6; // | version | num_sections | table_length | ...table | state_length | shuffle_state | prng_state | seed_length | ...seed |\n\n// Define the length of the \"fixed\" length portion of the state array:\nvar STATE_FIXED_LENGTH = TABLE_LENGTH + 7; // 1 (version) + 1 (num_sections) + 1 (table_length) + TABLE_LENGTH (table) + 1 (state_length) + 1 (shuffle_state) + 1 (prng_state) + 1 (seed_length)\n\n// Define the indices for the shuffle table and PRNG states:\nvar SHUFFLE_STATE = STATE_SECTION_OFFSET + 1;\nvar PRNG_STATE = STATE_SECTION_OFFSET + 2;\n\n\n// FUNCTIONS //\n\n/**\n* Verifies state array integrity.\n*\n* @private\n* @param {Int32Array} state - state array\n* @param {boolean} FLG - flag indicating whether the state array was provided as an option (true) or an argument (false)\n* @returns {(Error|null)} an error or `null`\n*/\nfunction verifyState( state, FLG ) {\n\tvar s1;\n\tif ( FLG ) {\n\t\ts1 = 'option';\n\t} else {\n\t\ts1 = 'argument';\n\t}\n\t// The state array must have a minimum length...\n\tif ( state.length < STATE_FIXED_LENGTH+1 ) {\n\t\treturn new RangeError( format( 'invalid %s. `state` array has insufficient length.', s1 ) );\n\t}\n\t// The first element of the state array must equal the supported state array schema version...\n\tif ( state[ 0 ] !== STATE_ARRAY_VERSION ) {\n\t\treturn new RangeError( format( 'invalid %s. `state` array has an incompatible schema version. Expected: %s. Actual: %s.', s1, STATE_ARRAY_VERSION, state[ 0 ] ) );\n\t}\n\t// The second element of the state array must contain the number of sections...\n\tif ( state[ 1 ] !== NUM_STATE_SECTIONS ) {\n\t\treturn new RangeError( format( 'invalid %s. `state` array has an incompatible number of sections. Expected: %s. Actual: %s.', s1, NUM_STATE_SECTIONS, state[ 1 ] ) );\n\t}\n\t// The length of the \"table\" section must equal `TABLE_LENGTH`...\n\tif ( state[ TABLE_SECTION_OFFSET ] !== TABLE_LENGTH ) {\n\t\treturn new RangeError( format( 'invalid %s. `state` array has an incompatible table length. Expected: %s. Actual: %s.', s1, TABLE_LENGTH, state[ TABLE_SECTION_OFFSET ] ) );\n\t}\n\t// The length of the \"state\" section must equal `2`...\n\tif ( state[ STATE_SECTION_OFFSET ] !== 2 ) {\n\t\treturn new RangeError( format( 'invalid %s. `state` array has an incompatible state length. Expected: `%u`. Actual: `%u`.', s1, 2, state[ STATE_SECTION_OFFSET ] ) );\n\t}\n\t// The length of the \"seed\" section much match the empirical length...\n\tif ( state[ SEED_SECTION_OFFSET ] !== state.length-STATE_FIXED_LENGTH ) {\n\t\treturn new RangeError( format( 'invalid %s. `state` array length is incompatible with seed section length. Expected: `%u`. Actual: `%u`.', s1, state.length-STATE_FIXED_LENGTH, state[ SEED_SECTION_OFFSET ] ) );\n\t}\n\treturn null;\n}\n\n\n// MAIN //\n\n/**\n* Returns a linear congruential pseudorandom number generator (LCG) whose output is shuffled.\n*\n* @param {Options} [options] - options\n* @param {PRNGSeedMINSTD} [options.seed] - pseudorandom number generator seed\n* @param {PRNGStateMINSTD} [options.state] - pseudorandom number generator state\n* @param {boolean} [options.copy=true] - boolean indicating whether to copy a provided pseudorandom number generator state\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} a seed must be either a positive integer less than the maximum signed 32-bit integer or an array-like object containing integers less than the maximum signed 32-bit integer\n* @throws {RangeError} a numeric seed must be a positive integer less than the maximum signed 32-bit integer\n* @throws {TypeError} state must be an `Int32Array`\n* @throws {Error} must provide a valid state\n* @throws {TypeError} `copy` option must be a boolean\n* @returns {PRNG} shuffled LCG PRNG\n*\n* @example\n* var minstd = factory();\n*\n* var v = minstd();\n* // returns <number>\n*\n* @example\n* // Return a seeded LCG:\n* var minstd = factory({\n*     'seed': 1234\n* });\n*\n* var v = minstd();\n* // returns 1421600654\n*/\nfunction factory( options ) {\n\tvar STATE;\n\tvar state;\n\tvar opts;\n\tvar seed;\n\tvar slen;\n\tvar err;\n\n\topts = {};\n\tif ( arguments.length ) {\n\t\tif ( !isObject( options ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );\n\t\t}\n\t\tif ( hasOwnProp( options, 'copy' ) ) {\n\t\t\topts.copy = options.copy;\n\t\t\tif ( !isBoolean( options.copy ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid option. `%s` option must be a boolean. Option: `%s`.', 'copy', options.copy ) );\n\t\t\t}\n\t\t}\n\t\tif ( hasOwnProp( options, 'state' ) ) {\n\t\t\tstate = options.state;\n\t\t\topts.state = true;\n\t\t\tif ( !isInt32Array( state ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid option. `%s` option must be an Int32Array. Option: `%s`.', 'state', state ) );\n\t\t\t}\n\t\t\terr = verifyState( state, true );\n\t\t\tif ( err ) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tif ( opts.copy === false ) {\n\t\t\t\tSTATE = state;\n\t\t\t} else {\n\t\t\t\tSTATE = new Int32Array( state.length );\n\t\t\t\tgcopy( state.length, state, 1, STATE, 1 );\n\t\t\t}\n\t\t\t// Create a state (table) \"view\":\n\t\t\tstate = new Int32Array( STATE.buffer, STATE.byteOffset+((TABLE_SECTION_OFFSET+1)*STATE.BYTES_PER_ELEMENT), TABLE_LENGTH );\n\n\t\t\t// Create a seed \"view\":\n\t\t\tseed = new Int32Array( STATE.buffer, STATE.byteOffset+((SEED_SECTION_OFFSET+1)*STATE.BYTES_PER_ELEMENT), state[ SEED_SECTION_OFFSET ] );\n\t\t}\n\t\t// If provided a PRNG state, we ignore the `seed` option...\n\t\tif ( seed === void 0 ) {\n\t\t\tif ( hasOwnProp( options, 'seed' ) ) {\n\t\t\t\tseed = options.seed;\n\t\t\t\topts.seed = true;\n\t\t\t\tif ( isPositiveInteger( seed ) ) {\n\t\t\t\t\tif ( seed > MAX_SEED ) {\n\t\t\t\t\t\tthrow new RangeError( format( 'invalid option. `%s` option must be a positive integer less than the maximum signed 32-bit integer. Option: `%u`.', 'seed', seed ) );\n\t\t\t\t\t}\n\t\t\t\t\tseed |= 0; // asm type annotation\n\t\t\t\t} else if ( isCollection( seed ) && seed.length > 0 ) {\n\t\t\t\t\tslen = seed.length;\n\t\t\t\t\tSTATE = new Int32Array( STATE_FIXED_LENGTH+slen );\n\n\t\t\t\t\t// Initialize sections:\n\t\t\t\t\tSTATE[ 0 ] = STATE_ARRAY_VERSION;\n\t\t\t\t\tSTATE[ 1 ] = NUM_STATE_SECTIONS;\n\t\t\t\t\tSTATE[ TABLE_SECTION_OFFSET ] = TABLE_LENGTH;\n\t\t\t\t\tSTATE[ STATE_SECTION_OFFSET ] = 2;\n\t\t\t\t\tSTATE[ PRNG_STATE ] = seed[ 0 ];\n\t\t\t\t\tSTATE[ SEED_SECTION_OFFSET ] = slen;\n\n\t\t\t\t\t// Copy the provided seed array to prevent external mutation, as mutation would lead to an inability to reproduce PRNG values according to the PRNG's stated seed:\n\t\t\t\t\tgcopy.ndarray( slen, seed, 1, 0, STATE, 1, SEED_SECTION_OFFSET+1 );\n\n\t\t\t\t\t// Create a state (table) \"view\":\n\t\t\t\t\tstate = new Int32Array( STATE.buffer, STATE.byteOffset+((TABLE_SECTION_OFFSET+1)*STATE.BYTES_PER_ELEMENT), TABLE_LENGTH );\n\n\t\t\t\t\t// Create a seed \"view\":\n\t\t\t\t\tseed = new Int32Array( STATE.buffer, STATE.byteOffset+((SEED_SECTION_OFFSET+1)*STATE.BYTES_PER_ELEMENT), slen );\n\n\t\t\t\t\t// Initialize the internal PRNG state:\n\t\t\t\t\tstate = createTable( minstd, state, TABLE_LENGTH );\n\t\t\t\t\tSTATE[ SHUFFLE_STATE ] = state[ 0 ];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError( format( 'invalid option. `%s` option must be either a positive integer less than the maximum signed 32-bit integer or an array-like object containing integer values less than the maximum signed 32-bit integer. Option: `%s`.', 'seed', seed ) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tseed = randint32()|0; // asm type annotation\n\t\t\t}\n\t\t}\n\t} else {\n\t\tseed = randint32()|0; // asm type annotation\n\t}\n\tif ( state === void 0 ) {\n\t\tSTATE = new Int32Array( STATE_FIXED_LENGTH+1 );\n\n\t\t// Initialize sections:\n\t\tSTATE[ 0 ] = STATE_ARRAY_VERSION;\n\t\tSTATE[ 1 ] = NUM_STATE_SECTIONS;\n\t\tSTATE[ TABLE_SECTION_OFFSET ] = TABLE_LENGTH;\n\t\tSTATE[ STATE_SECTION_OFFSET ] = 2;\n\t\tSTATE[ PRNG_STATE ] = seed;\n\t\tSTATE[ SEED_SECTION_OFFSET ] = 1;\n\t\tSTATE[ SEED_SECTION_OFFSET+1 ] = seed;\n\n\t\t// Create a state (table) \"view\":\n\t\tstate = new Int32Array( STATE.buffer, STATE.byteOffset+((TABLE_SECTION_OFFSET+1)*STATE.BYTES_PER_ELEMENT), TABLE_LENGTH );\n\n\t\t// Create a seed \"view\":\n\t\tseed = new Int32Array( STATE.buffer, STATE.byteOffset+((SEED_SECTION_OFFSET+1)*STATE.BYTES_PER_ELEMENT), 1 );\n\n\t\t// Initialize the internal PRNG state:\n\t\tstate = createTable( minstd, state, TABLE_LENGTH );\n\t\tSTATE[ SHUFFLE_STATE ] = state[ 0 ];\n\t}\n\tsetReadOnly( minstdShuffle, 'NAME', 'minstd-shuffle' );\n\tsetReadOnlyAccessor( minstdShuffle, 'seed', getSeed );\n\tsetReadOnlyAccessor( minstdShuffle, 'seedLength', getSeedLength );\n\tsetReadWriteAccessor( minstdShuffle, 'state', getState, setState );\n\tsetReadOnlyAccessor( minstdShuffle, 'stateLength', getStateLength );\n\tsetReadOnlyAccessor( minstdShuffle, 'byteLength', getStateSize );\n\tsetReadOnly( minstdShuffle, 'toJSON', toJSON );\n\tsetReadOnly( minstdShuffle, 'MIN', 1 );\n\tsetReadOnly( minstdShuffle, 'MAX', INT32_MAX-1 );\n\tsetReadOnly( minstdShuffle, 'normalized', normalized );\n\n\tsetReadOnly( normalized, 'NAME', minstdShuffle.NAME );\n\tsetReadOnlyAccessor( normalized, 'seed', getSeed );\n\tsetReadOnlyAccessor( normalized, 'seedLength', getSeedLength );\n\tsetReadWriteAccessor( normalized, 'state', getState, setState );\n\tsetReadOnlyAccessor( normalized, 'stateLength', getStateLength );\n\tsetReadOnlyAccessor( normalized, 'byteLength', getStateSize );\n\tsetReadOnly( normalized, 'toJSON', toJSON );\n\tsetReadOnly( normalized, 'MIN', (minstdShuffle.MIN-1.0) / NORMALIZATION_CONSTANT );\n\tsetReadOnly( normalized, 'MAX', (minstdShuffle.MAX-1.0) / NORMALIZATION_CONSTANT );\n\n\treturn minstdShuffle;\n\n\t/**\n\t* Returns the PRNG seed.\n\t*\n\t* @private\n\t* @returns {PRNGSeedMINSTD} seed\n\t*/\n\tfunction getSeed() {\n\t\tvar len = STATE[ SEED_SECTION_OFFSET ];\n\t\treturn gcopy( len, seed, 1, new Int32Array( len ), 1 );\n\t}\n\n\t/**\n\t* Returns the PRNG seed length.\n\t*\n\t* @private\n\t* @returns {PositiveInteger} seed length\n\t*/\n\tfunction getSeedLength() {\n\t\treturn STATE[ SEED_SECTION_OFFSET ];\n\t}\n\n\t/**\n\t* Returns the PRNG state length.\n\t*\n\t* @private\n\t* @returns {PositiveInteger} state length\n\t*/\n\tfunction getStateLength() {\n\t\treturn STATE.length;\n\t}\n\n\t/**\n\t* Returns the PRNG state size (in bytes).\n\t*\n\t* @private\n\t* @returns {PositiveInteger} state size (in bytes)\n\t*/\n\tfunction getStateSize() {\n\t\treturn STATE.byteLength;\n\t}\n\n\t/**\n\t* Returns the current PRNG state.\n\t*\n\t* ## Notes\n\t*\n\t* -   The PRNG state array is comprised of a preamble followed by `3` sections:\n\t*\n\t*     0.  preamble (version + number of sections)\n\t*     1.  shuffle table\n\t*     2.  internal PRNG state\n\t*     3.  PRNG seed\n\t*\n\t* -   The first element of the PRNG state array preamble is the state array schema version.\n\t*\n\t* -   The second element of the PRNG state array preamble is the number of state array sections (i.e., `3`).\n\t*\n\t* -   The first element of each section following the preamble specifies the section length. The remaining section elements comprise the section contents.\n\t*\n\t* @private\n\t* @returns {PRNGStateMINSTD} current state\n\t*/\n\tfunction getState() {\n\t\tvar len = STATE.length;\n\t\treturn gcopy( len, STATE, 1, new Int32Array( len ), 1 );\n\t}\n\n\t/**\n\t* Sets the PRNG state.\n\t*\n\t* ## Notes\n\t*\n\t* -   If PRNG state is \"shared\" (meaning a state array was provided during PRNG creation and **not** copied) and one sets the generator state to a state array having a different length, the PRNG does **not** update the existing shared state and, instead, points to the newly provided state array. In order to synchronize PRNG output according to the new shared state array, the state array for **each** relevant PRNG must be **explicitly** set.\n\t* -   If PRNG state is \"shared\" and one sets the generator state to a state array of the same length, the PRNG state is updated (along with the state of all other PRNGs sharing the PRNG's state array).\n\t*\n\t* @private\n\t* @param {PRNGStateMINSTD} s - generator state\n\t* @throws {TypeError} must provide an `Int32Array`\n\t* @throws {Error} must provide a valid state\n\t*/\n\tfunction setState( s ) {\n\t\tvar err;\n\t\tif ( !isInt32Array( s ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Must provide an Int32Array. Value: `%s`.', s ) );\n\t\t}\n\t\terr = verifyState( s, false );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t\tif ( opts.copy === false ) {\n\t\t\tif ( opts.state && s.length === STATE.length ) {\n\t\t\t\tgcopy( s.length, s, 1, STATE, 1 ); // update current shared state\n\t\t\t} else {\n\t\t\t\tSTATE = s; // point to new shared state\n\t\t\t\topts.state = true; // setting this flag allows updating a shared state even if a state array was not provided at PRNG creation\n\t\t\t}\n\t\t} else {\n\t\t\t// Check if we can reuse allocated memory...\n\t\t\tif ( s.length !== STATE.length ) {\n\t\t\t\tSTATE = new Int32Array( s.length ); // reallocate\n\t\t\t}\n\t\t\tgcopy( s.length, s, 1, STATE, 1 );\n\t\t}\n\t\t// Create a new state (table) \"view\":\n\t\tstate = new Int32Array( STATE.buffer, STATE.byteOffset+((TABLE_SECTION_OFFSET+1)*STATE.BYTES_PER_ELEMENT), TABLE_LENGTH );\n\n\t\t// Create a new seed \"view\":\n\t\tseed = new Int32Array( STATE.buffer, STATE.byteOffset+((SEED_SECTION_OFFSET+1)*STATE.BYTES_PER_ELEMENT), STATE[ SEED_SECTION_OFFSET ] );\n\t}\n\n\t/**\n\t* Serializes the pseudorandom number generator as a JSON object.\n\t*\n\t* ## Notes\n\t*\n\t* -   `JSON.stringify()` implicitly calls this method when stringifying a PRNG.\n\t*\n\t* @private\n\t* @returns {Object} JSON representation\n\t*/\n\tfunction toJSON() {\n\t\tvar out = {};\n\t\tout.type = 'PRNG';\n\t\tout.name = minstdShuffle.NAME;\n\t\tout.state = typedarray2json( STATE );\n\t\tout.params = [];\n\t\treturn out;\n\t}\n\n\t/**\n\t* Generates a pseudorandom integer on the interval \\\\( [1,2^{31}-1) \\\\).\n\t*\n\t* @private\n\t* @returns {integer32} pseudorandom integer\n\t*/\n\tfunction minstd() {\n\t\tvar s = STATE[ PRNG_STATE ]|0; // asm type annotation\n\t\ts = ( (A*s)%INT32_MAX )|0; // asm type annotation\n\t\tSTATE[ PRNG_STATE ] = s;\n\t\treturn s|0; // asm type annotation\n\t}\n\n\t/**\n\t* Generates a pseudorandom integer on the interval \\\\( [1,2^{31}-1) \\\\).\n\t*\n\t* @private\n\t* @returns {integer32} pseudorandom integer\n\t*\n\t* @example\n\t* var v = minstd();\n\t* // returns <number>\n\t*/\n\tfunction minstdShuffle() {\n\t\tvar s;\n\t\tvar i;\n\n\t\ts = STATE[ SHUFFLE_STATE ];\n\t\ti = floor( TABLE_LENGTH * (s/INT32_MAX) );\n\n\t\t// Pull a state from the table:\n\t\ts = state[ i ];\n\n\t\t// Update the PRNG state:\n\t\tSTATE[ SHUFFLE_STATE ] = s;\n\n\t\t// Replace the pulled state:\n\t\tstate[ i ] = minstd();\n\n\t\treturn s;\n\t}\n\n\t/**\n\t* Generates a pseudorandom number on the interval \\\\( [0,1) \\\\).\n\t*\n\t* @private\n\t* @returns {number} pseudorandom number\n\t*\n\t* @example\n\t* var v = normalized();\n\t* // returns <number>\n\t*/\n\tfunction normalized() {\n\t\treturn (minstdShuffle()-1) / NORMALIZATION_CONSTANT;\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = factory;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* A linear congruential pseudorandom number generator (LCG) whose output is shuffled.\n*\n* @module @stdlib/random-base-minstd-shuffle\n*\n* @example\n* var minstd = require( '@stdlib/random-base-minstd-shuffle' );\n*\n* var v = minstd();\n* // returns <number>\n*\n* @example\n* var factory = require( '@stdlib/random-base-minstd-shuffle' ).factory;\n*\n* var minstd = factory({\n*     'seed': 1234\n* });\n*\n* var v = minstd();\n* // returns 1421600654\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar minstd = require( './main.js' );\nvar factory = require( './factory.js' );\n\n\n// MAIN //\n\nsetReadOnly( minstd, 'factory', factory );\n\n\n// EXPORTS //\n\nmodule.exports = minstd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar factory = require( './factory.js' );\nvar randint32 = require( './rand_int32.js' );\n\n\n// MAIN //\n\n/**\n* Generates a pseudorandom integer on the interval \\\\( [1,2^{31}-1) \\\\).\n*\n* ## Method\n*\n* Linear congruential generators (LCGs) use the recurrence relation\n*\n* ```tex\n* X_{n+1} = ( a \\cdot X_n + c ) \\operatorname{mod}(m)\n* ```\n*\n* where the modulus \\\\( m \\\\) is a prime number or power of a prime number and \\\\( a \\\\) is a primitive root modulo \\\\( m \\\\).\n*\n* <!-- <note> -->\n*\n* For an LCG to be a Lehmer RNG, the seed \\\\( X_0 \\\\) must be coprime to \\\\( m \\\\).\n*\n* <!-- </note> -->\n*\n* In this implementation, the constants \\\\( a \\\\), \\\\( c \\\\), and \\\\( m \\\\) have the values\n*\n* ```tex\n* \\begin{align*}\n* a &= 7^5 = 16807 \\\\\n* c &= 0 \\\\\n* m &= 2^{31} - 1 = 2147483647\n* \\end{align*}\n* ```\n*\n* <!-- <note> -->\n*\n* The constant \\\\( m \\\\) is a Mersenne prime (modulo \\\\(31\\\\)).\n*\n* <!-- </note> -->\n*\n* <!-- <note> -->\n*\n* The constant \\\\( a \\\\) is a primitive root (modulo \\\\(31\\\\)).\n*\n* <!-- </note> -->\n*\n* Accordingly, the maximum possible product is\n*\n* ```tex\n* 16807 \\cdot (m - 1) \\approx 2^{46}\n* ```\n*\n* The values for \\\\( a \\\\), \\\\( c \\\\), and \\\\( m \\\\) are taken from Park and Miller, \"Random Number Generators: Good Ones Are Hard To Find\". Park's and Miller's article is also the basis for a recipe in the second edition of _Numerical Recipes in C_.\n*\n* This implementation subsequently shuffles the output of a linear congruential pseudorandom number generator (LCG) using a shuffle table in accordance with the Bays-Durham algorithm.\n*\n*\n* ## Notes\n*\n* -   The generator has a period of approximately \\\\(2.1\\mbox{e}9\\\\) (see [Numerical Recipes in C, 2nd Edition](#references), p. 279).\n*\n*\n* ## References\n*\n* -   Bays, Carter, and S. D. Durham. 1976. \"Improving a Poor Random Number Generator.\" _ACM Transactions on Mathematical Software_ 2 (1). New York, NY, USA: ACM: 59–64. doi:[10.1145/355666.355670](http://dx.doi.org/10.1145/355666.355670).\n* -   Herzog, T.N., and G. Lord. 2002. _Applications of Monte Carlo Methods to Finance and Insurance_. ACTEX Publications. [https://books.google.com/books?id=vC7I\\\\\\_gdX-A0C](https://books.google.com/books?id=vC7I\\_gdX-A0C).\n* -   Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T. Vetterling. 1992. _Numerical Recipes in C: The Art of Scientific Computing, Second Edition_. Cambridge University Press.\n*\n*\n* @function minstd\n* @type {PRNG}\n* @returns {PositiveInteger} pseudorandom integer\n*\n* @example\n* var v = minstd();\n* // returns <number>\n*/\nvar minstd = factory({\n\t'seed': randint32()\n});\n\n\n// EXPORTS //\n\nmodule.exports = minstd;\n"],"names":["isnan","require$$0","create_table","rand","table","N","v","i","Error","floor","require$$1","MAX","rand_int32","Math","random","setReadOnly","setReadOnlyAccessor","setReadWriteAccessor","require$$2","hasOwnProp","require$$3","isObject","require$$4","isBoolean","require$$5","isPrimitive","isCollection","require$$6","isPositiveInteger","require$$7","isInt32Array","require$$8","gcopy","require$$9","require$$10","Int32Array","require$$11","INT32_MAX","require$$12","typedarray2json","require$$13","format","require$$14","createTable","require$$15","randint32","require$$16","NORMALIZATION_CONSTANT","MAX_SEED","verifyState","state","FLG","s1","length","STATE_FIXED_LENGTH","RangeError","TABLE_LENGTH","factory_1","options","STATE","opts","seed","slen","err","arguments","TypeError","copy","buffer","byteOffset","BYTES_PER_ELEMENT","STATE_SECTION_OFFSET","ndarray","SEED_SECTION_OFFSET","minstd","minstdShuffle","getSeed","getSeedLength","getState","setState","getStateLength","getStateSize","toJSON","normalized","NAME","MIN","len","byteLength","s","out","name","params","factory","lib"],"mappings":"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"}